import { Callout, Tabs, Table, Td, Th, Tr, Code } from "nextra/components";

# Configuration

Carrot's Compose Container stack consists of 6 services or containers working together. This page will give details about these services.

## Django Backend: `api`

```yaml
api:
  image: carrot-backend
  build:
    context: app
    dockerfile: api/Dockerfile
  ports:
    - 8000:8000
  environment:
    - FRONTEND_URL=http://frontend:3000
    - ALLOWED_HOSTS=['localhost', '127.0.0.1','api', 'workers']
    - DB_ENGINE=django.db.backends.postgresql
    - DB_HOST=db
    - DB_PORT=5432
    - DB_NAME=postgres
    - DB_USER=postgres
    - DB_PASSWORD=postgres
    - DEBUG=True
    - WORKERS_UPLOAD_NAME=uploadreports-local
    - SECRET_KEY=secret
    - WORKERS_URL=http://workers:80
    - WORKERS_RULES_NAME=RulesOrchestrator
    - WORKERS_RULES_KEY=rules_key
    - WORKERS_RULES_EXPORT_NAME=rules-exports-local
    - STORAGE_CONN_STRING=DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://azurite:10000/devstoreaccount1;QueueEndpoint=http://azurite:10001/devstoreaccount1;TableEndpoint=http://azurite:10002/devstoreaccount1;
    - SIGNING_KEY=secret
  volumes:
    - ./app/api:/api
  depends_on:
    omop-lite:
      condition: service_completed_successfully
```

This service is built based on the Dockerfile inside `app/api/` folder and exposed on port `8000:8000`. It will start after the `omop-lite` service ran and did its jobs successfully. When running, it also uses the mounted code in the `api` folder so the changes will be reflected without restarting the stack.

Below is the description for the service's environment variables which are required for it to run properly:

<Table>
  <thead>
    <Tr>
      <Th>Key</Th>
      <Th>Description</Th>
    </Tr>
  </thead>
  <tbody>
    <Tr>
      <Td>`FRONTEND_URL`</Td>
      <Td>
        The URL for Frontend service which `Backend` should connect to. This only
        needs to include scheme (e.g. `http://`), host (`my-fronted.com`, or in
        this example, `frontend` in order to connect with service in the same
        compose stack) and optionally port, e.g., `3000`.
      </Td>
    </Tr>
    <Tr>
      <Td>`ALLOWED_HOSTS`</Td>
      <Td>
        A list of strings representing the host/domain names that this Django
        site can serve.
      </Td>
    </Tr>
    <Tr>
      <Td>`DB_ENGINE`</Td>
      <Td>
        The database backend to use. Carrot uses `Postgres` database backend.
      </Td>
    </Tr>
    <Tr>
      <Td>`DB_HOST` `DB_PORT` `DB_NAME` `DB_USER` `DB_PASSWORD`</Td>
      <Td>
        These settings (`port`, `host`, `name`, `user`, `password`) are required
        for PostgreSQL database connection.
      </Td>
    </Tr>
    <Tr>
      <Td>`DEBUG`</Td>
      <Td>A boolean that turns on/off debug mode.</Td>
    </Tr>
    <Tr>
      <Td>`WORKERS_URL`</Td>
      <Td>The URL for `Workers` (Azure functions) service which `Backend` should connect to. Structure is similar to `FRONTEND_URL`.</Td>
    </Tr>
    <Tr>
      <Td>
        `WORKERS_UPLOAD_NAME` `WORKERS_RULES_EXPORT_NAME`
      </Td>
      <Td>Name of queues in Azurite that `Workers` send messages about ScanReport uploads and Mapping Rules exports, respectively.</Td>
    </Tr>
    <Tr>
      <Td>
        `WORKERS_RULES_NAME`
      </Td>
      <Td>Name of point where `Backend` triggers Workers' jobs.</Td>
    </Tr>
    <Tr>
      <Td>`WORKERS_RULES_KEY`</Td>
      <Td>The key to authorise the request sent to `Workers` from `Backend`.</Td>
    </Tr>
    <Tr>
      <Td>`STORAGE_CONN_STRING`</Td>
      <Td>The key to connect Backend and Azure local storage.</Td>
    </Tr>

    <Tr>
      <Td>`SECRET_KEY`</Td>
      <Td>A secret key for a particular Django installation. This is used to provide cryptographic signing, and should be set to a unique, unpredictable value. Real value is used in Production.</Td>
    </Tr>
    <Tr>
      <Td>`SIGNING_KEY`</Td>
      <Td>A key required in JWT token generation process for Next Auth. Real value is used in Production.</Td>
    </Tr>

  </tbody>
</Table>

## NextJS Frontend: `frontend`

```yaml
frontend:
  image: carrot-frontend
  build:
    context: app/next-client-app
    dockerfile: Dockerfile
    target: dev
  command: npm run dev
  ports:
    - 3000:3000
  environment:
    - BACKEND_URL=http://api:8000
    - BACKEND_ORIGIN=localhost:8000
    - NEXTAUTH_URL=http://localhost:3000/
    - NEXTAUTH_SECRET=verycomplexsecretkey
    - NEXTAUTH_BACKEND_URL=http://api:8000/api/
    - NODE_ENV=development
    - WATCHPACK_POLLING=true
  volumes:
    - ./app/next-client-app:/app
    - /app/node_modules
    - /app/.next
  depends_on:
    - api
```

This service is built based on the Dockerfile inside `app/next-client-app/` folder and exposed on port `3000:3000`. It will start after the `api` service is successfully up. When running, it also uses the mounted code in the `next-client-app` folder so the changes will be reflected without restarting the stack.

Below is the description for the service's environment variables which are required for it to run properly:

<Table>
  <thead>
    <Tr>
      <Th>Key</Th>
      <Th>Description</Th>
    </Tr>
  </thead>
  <tbody>
    <Tr>
      <Td>`BACKEND_URL`</Td>
      <Td>
        The URL for Backend service which `frontend` should connect to. This
        only needs to include scheme (e.g. `http://`), host (`my-fronted.com`,
        or in this example, `api` in order to connect with service in the same
        compose stack) and optionally port, e.g., `8000`.
      </Td>
    </Tr>
    <Tr>
      <Td>`BACKEND_ORIGIN`</Td>
      <Td>
        A list of extra safe origin domains from which Server Actions can be
        invoked. Next.js compares the origin of a Server Action request with the
        host domain, ensuring they match to prevent CSRF attacks.
      </Td>
    </Tr>
    <Tr>
      <Td>`NODE_ENV` `WATCHPACK_POLLING`</Td>
      <Td>
        These variables are set to enable `hot reload` feature when developing
        NextJS app.
      </Td>
    </Tr>
    <Tr>
      <Td>`NEXTAUTH_BACKEND_URL`</Td>
      <Td>
        The backend base endpoint URL where `Frontend` send auth requests to.
      </Td>
    </Tr>
    <Tr>
      <Td>`NEXTAUTH_SECRET`</Td>
      <Td>
        Used to encrypt the NextAuth.js JWT, and to hash email verification
        tokens. Real value is used in Production.
      </Td>
    </Tr>
    <Tr>
      <Td>`NEXTAUTH_URL`</Td>
      <Td>The base URL where login and logout processes point to.</Td>
    </Tr>
  </tbody>
</Table>

## Azure functions: `workers`

```yaml
workers:
  image: carrot-workers
  build:
    context: app
    dockerfile: workers/Dockerfile
  ports:
    - 8080:80
    - 7071:80
  environment:
    - AzureWebJobsSecretStorageType=files
    - IsEncrypted=false
    - AzureWebJobsStorage=DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://azurite:10000/devstoreaccount1;QueueEndpoint=http://azurite:10001/devstoreaccount1;TableEndpoint=http://azurite:10002/devstoreaccount1;
    - FUNCTIONS_WORKER_RUNTIME=python
    - STORAGE_CONN_STRING=DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://azurite:10000/devstoreaccount1;QueueEndpoint=http://azurite:10001/devstoreaccount1;TableEndpoint=http://azurite:10002/devstoreaccount1;
    - APP_URL=http://api:8000/
    - WORKERS_UPLOAD_NAME=uploadreports-local
    - RULES_QUEUE_NAME=rules-local
    - RULES_FILE_QUEUE_NAME=rules-exports-local
    - WEBSITE_HOSTNAME=localhost:7071
    - DB_ENGINE=django.db.backends.postgresql
    - DB_HOST=db
    - DB_PORT=5432
    - DB_NAME=postgres
    - DB_USER=postgres
    - DB_PASSWORD=postgres
  volumes:
    - ./app/workers:/home/site/wwwroot
    - ./app/shared:/shared
    - ./app/workers/Secrets:/azure-functions-host/Secrets/
  depends_on:
    - api
    - azurite
```

This service is built based on the Dockerfile inside `app/workers/` folder and exposed on ports `8080:80` and `7071:80`. It will start after the `api` and `azurite` services are successfully up. When running, it also created some volumes that support its functionalities and authentication.

Below is the description for the service's environment variables which are required for it to run properly:

<Table>
  <thead>
    <Tr>
      <Th>Key</Th>
      <Th>Description</Th>
    </Tr>
  </thead>
  <tbody>
    <Tr>
      <Td>`AzureWebJobsSecretStorageType`</Td>
      <Td>
        Specifies the repository or provider to use for key storage. Carrot's
        workers uses this as `files` for workers auth keys are persisted on the
        file system. In other words, we ask Docker to look for secrets locally
        which created at [step
        2](quickstart#authentication-setup-for-azure-functions) in the dev.
        quickstart.
      </Td>
    </Tr>
    <Tr>
      <Td>`IsEncrypted`</Td>
      <Td>
        This setting represents whether the values in local.settings.json are
        encrypted using a local machine key.
      </Td>
    </Tr>
    <Tr>
      <Td>`FUNCTIONS_WORKER_RUNTIME`</Td>
      <Td>
        The language or language stack of the worker runtime to load in the
        function app.
      </Td>
    </Tr>
    <Tr>
      <Td>`DB_ENGINE`</Td>
      <Td>
        The database backend to use. Carrot's workers uses `Postgres` database
        backend.
      </Td>
    </Tr>
    <Tr>
      <Td>`DB_HOST` `DB_PORT` `DB_NAME` `DB_USER` `DB_PASSWORD`</Td>
      <Td>
        These settings (`port`, `host`, `name`, `user`, `password`) are required
        for PostgreSQL database connection.
      </Td>
    </Tr>
    <Tr>
      <Td>`RULES_QUEUE_NAME` `RULES_FILE_QUEUE_NAME` `WORKERS_UPLOAD_NAME`</Td>
      <Td>
        Name of queues in Azurite that `Workers` send messages about Rules
        actions triggers, Mapping Rules exports and ScanReport uploads,
        respectively.
      </Td>
    </Tr>
    <Tr>
      <Td>`WEBSITE_HOSTNAME`</Td>
      <Td>
        The address that can be used to reach the function app from outside.
      </Td>
    </Tr>
    <Tr>
      <Td>`STORAGE_CONN_STRING` `AzureWebJobsStorage`</Td>
      <Td>The keys to connect Workers and Azure local storage.</Td>
    </Tr>
  </tbody>
</Table>

## Results Obfuscation

**Configuration Section: `Obfuscation`**

<Table>
  <thead>
    <Tr>
      <Th>Key</Th>
      <Th>Description</Th>
    </Tr>
  </thead>
  <tbody>
    <Tr>
      <Td>`LowNumberSuppressionThreshold`</Td>
      <Td>
        A positive number will set the threshold below which Relay will suppress
        and return `0`.

        Defaults to `0` (effectively off).
      </Td>
    </Tr>
    <Tr>
      <Td>`RoundingTarget`</Td>
      <Td>
        The target nearest number to round up to, e.g. `10` will round both
        `171` and `179` to `180`.

        Defaults to `0` (effectively off).
      </Td>
    </Tr>

  </tbody>
</Table>

Examples:

<Tabs items={['Environment', 'Compose', 'JSON']}>
  <Tabs.Tab>
    ```bash filename=".env" copy
    Obfuscation__LowNumberSuppressionThreshold=50
    Obfuscation__RoundingTarget=5
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```yaml filename="compose.yml" copy
    environment:
      Obfuscation__LowNumberSuppressionThreshold: 50
      Obfuscation__RoundingTarget: 5
    ```

  </Tabs.Tab>
  <Tabs.Tab>
    ```json filename="secrets.json" copy
    {
      "Obfuscation": {
        "LowNumberSuppressionThreshold": 50,
        "RoundingTarget": 5
      }
    }
    ```

  </Tabs.Tab>
</Tabs>

## ASP.NET Core

Since Relay is an ASP.NET Core application, there are some capabilities of that framework that can be configured in the standard way.

Examples of this include [logging levels](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/logging/#configure-logging)
and [hosting configuration](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/servers/kestrel/endpoints) (e.g. bind addresses, TLS...).

Please refer to the [ASP.NET Core documentation](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/) on these topics.
